import java.io.File
import java.util.*

/*
 * Copyright 2019-2024 JetBrains s.r.o. and contributors.
 * Use of this source code is governed by the Apache 2.0 License that can be found in the LICENSE.txt file.
 */

private val tzdbUnneededFiles = setOf(
    // taken from https://github.com/tzinfo/tzinfo/blob/9953fc092424d55deaea2dcdf6279943f3495724/lib/tzinfo/data_sources/zoneinfo_data_source.rb#L88C29-L97C21
    "+VERSION",
    "leapseconds",
    "localtime",
    "posix",
    "posixrules",
    "right",
    "SECURITY",
    "src",
    "timeconfig",
    // taken from https://github.com/HowardHinnant/date/blob/ab37c362e35267d6dee02cb47760f9e9c669d3be/src/tz.cpp#L2863-L2874
    "Factory",
    "iso3166.tab",
    "zone.tab",
    "zone1970.tab",
    "tzdata.zi",
    "leap-seconds.list"
)

fun generateByteArrayProperty(bytes: ByteArray, header: String, propertyName: String): String = buildString {
    append(header)
    appendLine()
    appendLine()
    append("@OptIn(ExperimentalUnsignedTypes::class)")
    appendLine()
    append("internal val $propertyName get() = ubyteArrayOf(")
    for (chunk in bytes.toList().chunked(16)) {
        appendLine()
        append("    ")
        val chunkText = chunk.joinToString {
            it.toString()
            val converted = it.toUByte().toString(16)
            val byteText = if (converted.length == 1) "0x0${converted}U" else "0x${converted}U"
            byteText
        } + ","
        append(chunkText)
    }
    appendLine()
    append(")")
}

fun generateEncodedZoneInfo(
    zoneInfo: File,
    outputDirectory: File,
    dirSegments: List<String>,
    header: String,
    codeTable: MutableMap<Byte, CodeData>?
): Pair<String, String> {
    val propertyName = "${dirSegments.joinToString(separator = "") { it }}${zoneInfo.nameWithoutExtension}"
        .replace("+", "p")
        .replace("-", "m")

    val bytes = zoneInfo.readBytes()
    val encodedFile = codeTable?.let { encode(bytes, it) } ?: bytes
    val data = generateByteArrayProperty(encodedFile, header, propertyName)
    val dir = dirSegments.fold(outputDirectory, ::File)
    dir.mkdirs()
    val kt = File(dir, "${zoneInfo.nameWithoutExtension}.kt")
    kt.writeText(data)

    val zonePath = dirSegments.joinToString(separator = "/")
    val zoneName = if (zonePath.isEmpty()) zoneInfo.name else "$zonePath/${zoneInfo.name}"
    return zoneName to propertyName
}

fun generateEncodedZoneInfos(
    zoneInfo: File,
    outputDirectory: File,
    dirSegments: List<String>,
    header: String,
    codeTable: MutableMap<Byte, CodeData>?
): List<Pair<String, String>> {
    return if (zoneInfo.isDirectory) {
        zoneInfo.listFiles()?.flatMap {
            generateEncodedZoneInfos(it,  outputDirectory, dirSegments + zoneInfo.name, header, codeTable)
        } ?: emptyList()
    } else {
        listOf(generateEncodedZoneInfo(zoneInfo, outputDirectory, dirSegments, header, codeTable))
    }
}

fun buildFrequences(zoneInfoDir: File): IntArray {
    val maxIndex = UByte.MAX_VALUE.toInt() + 1
    val freqs = IntArray(maxIndex)
    zoneInfoDir.listFiles()?.filterNot { it.name in tzdbUnneededFiles }?.forEach {
        buildFrequences(it, freqs)
    } ?: error("NO FILES")
    return freqs
}

val license = """
            /*
             * Copyright 2019-2024 JetBrains s.r.o. and contributors.
             * Use of this source code is governed by the Apache 2.0 License that can be found in the LICENSE.txt file.
             */
        """.trimIndent()

val pkg = "package kotlinx.datetime.internal.tzData"

fun getAutoGeneratedString(zoneInfoDir: File): String {
    val versionFile = File(zoneInfoDir, "+VERSION")
    val version =
        if (!versionFile.exists() || !versionFile.isFile) "unknown" else versionFile.readLines().firstOrNull()
            ?: "unknown"
    return "/* AUTOGENERATED FROM ZONE INFO DATABASE v.$version */"
}

fun buildFrequences(f: File, freq: IntArray) {
    if (f.isDirectory) {
        f.listFiles()?.forEach { buildFrequences(it, freq) }
    } else {
        f.readBytes().forEach {
            val currentFreq = freq[it.toUByte().toInt()]
//                if (currentFreq == UByte.MAX_VALUE) error("Frequency overflow")
            freq[it.toUByte().toInt()] = (currentFreq + 1)
        }
    }
}

fun decode(message: ByteArray, tree: HuffmanTree): List<Byte> {
    val result = mutableListOf<Byte>()

    var currentNode = (tree as? HuffmanNode) ?: error("!!!")

    message.forEach { byte ->
        val currentByte = byte.toInt()
        for (i in 7 downTo 0) {
            val currentBit = (currentByte ushr i) and 1
            val newNode = if (currentBit == 0) currentNode.left else currentNode.right
            when (newNode) {
                is HuffmanNode -> currentNode = newNode
                is HuffmanLeaf -> {
                    result.add(newNode.value)
                    currentNode = tree
                }
            }
        }
    }

    return result
}

fun encode(message: ByteArray, codeTable: Map<Byte, CodeData>): ByteArray {
    val result = mutableListOf<Byte>()
    var currentByte = 0
    var currentBytePosition = 7
    fun writeBit(bit: Boolean) {
        if (bit) {
            currentByte = currentByte or (1 shl currentBytePosition)
        }
        currentBytePosition--

        if (currentBytePosition < 0) {
            result.add(currentByte.toByte())
            currentBytePosition = 7
            currentByte = 0
        }
    }

    message.forEach { ch ->
        val codeData = codeTable[ch]!!

        val currentCode = codeData.code
        for (i in codeData.nBits - 1 downTo 0) {
            val currentBit = ((currentCode shr i) and 1) == 1
            writeBit(currentBit)
        }
    }

    if (currentBytePosition != 7) {
        result.add(currentByte.toByte())
    }
    return result.toByteArray()
}

abstract class HuffmanTree(val freq: Int) : Comparable<HuffmanTree> {
    override fun compareTo(other: HuffmanTree): Int = freq - other.freq
}

class HuffmanLeaf(freq: Int, val value: Byte) : HuffmanTree(freq)

class HuffmanNode(val left: HuffmanTree, val right: HuffmanTree) : HuffmanTree(left.freq + right.freq)

fun buildTree(freq: IntArray) : HuffmanTree {
    val trees = PriorityQueue<HuffmanTree>()

    freq.forEachIndexed { index, freq ->
        if(freq > 0) trees.offer(HuffmanLeaf(freq, index.toByte()))
    }

    assert(trees.size > 0)
    while (trees.size > 1) {
        val a = trees.poll()
        val b = trees.poll()
        trees.offer(HuffmanNode(a, b))
    }

    return trees.poll()
}

class CodeData(val nBits: Int, val code: Int)

fun buildCodeTable(tree: HuffmanTree, depth: Int, code: Int, result: MutableMap<Byte, CodeData>) {
    when(tree) {
        is HuffmanLeaf -> {
            result[tree.value] = CodeData(depth, code)
        }
        is HuffmanNode -> {
            buildCodeTable(tree.left, depth + 1, code shl 1, result )
            buildCodeTable(tree.right, depth + 1, (code shl 1) or 1, result )
        }
    }
}

//fun buildCodeTable(zoneInfoDir: File, resultDir: File, header: String): MutableMap<Byte, CodeData> {
//    val freqs = buildFrequences(zoneInfoDir)
//    val freqsText = generateByteArrayProperty(freqs.toByteArray(), header, "frequencies")
//    resultDir.mkdirs()
//    File(resultDir, "tzFreq.kt").writeText(freqsText)
//
//    val tree = buildTree(freqs)
//    val codeTable = mutableMapOf<Byte, CodeData>()
//    buildCodeTable(tree, 0, 0, codeTable)
//    return codeTable
//}

fun generateWasmWasiZoneInfos(zoneInfoDir: File, outputDir: File) {
    if (!zoneInfoDir.exists() || !zoneInfoDir.isDirectory) error("zoneinfo does not exists")

    val header = buildString {
        append(license)
        appendLine()
        appendLine()
        append(getAutoGeneratedString(zoneInfoDir))
        appendLine()
        appendLine()
        append(pkg)
    }

    val ids = zoneInfoDir.listFiles()?.filterNot { it.name in tzdbUnneededFiles }?.flatMap {
        generateEncodedZoneInfos(it, outputDir, emptyList(), header, null)
    } ?: return


    val content = buildString {
        append(header)
        appendLine()
        appendLine()
        append("internal fun zoneDataByName(name: String): UByteArray = when(name) {")
        appendLine()
        ids.forEach {
            append("    \"${it.first}\" -> ${it.second}")
            appendLine()
        }
        append("    else -> error(\"Invalid timezone name\")")
        appendLine()
        append("}")
        appendLine()
        appendLine()
        append("internal fun getTimeZones(): Set<String> = setOf(")
        appendLine()
        append(ids.joinToString(separator = ",\n") { "    \"${it.first}\"" })
        appendLine()
        append(")")
    }


    File(outputDir, "tzData.kt").writeText(content)
}